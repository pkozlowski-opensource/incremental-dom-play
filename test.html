<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" type="text/css" href="node_modules/jasmine-core/lib/jasmine-core/jasmine.css">

    <script type="text/javascript" src="idom_variant.js"></script>
    <script type="text/javascript" src="renderer.js"></script>
    <script type="text/javascript" src="node_modules/jasmine-core/lib/jasmine-core/jasmine.js"></script>
    <script type="text/javascript" src="node_modules/jasmine-core/lib/jasmine-core/jasmine-html.js"></script>
    <script type="text/javascript" src="node_modules/jasmine-core/lib/jasmine-core/boot.js"></script>
    <script>
        var noopRenderer = new NoopRenderer();

        function NoopRenderer() {}

        NoopRenderer.prototype.createElement = function createElement(value) {
        };

        NoopRenderer.prototype.createText = function createText(value) {
        };

        NoopRenderer.prototype.updateText = function updateText(value) {
        };

        NoopRenderer.prototype.appendChild = function appendChild(parentNode, childNode) {
        };

        NoopRenderer.prototype.getRoot = function getRoot() {
        };

        NoopRenderer.prototype.insertBefore = function insertBefore(parentNode, refNode, newNode) {
        };

        NoopRenderer.prototype.removeNode = function removeNode(parentNode, node) {
        };

        NoopRenderer.prototype.setAttribute = function setAttribute(node, attrName, attrValue) {
        };

        NoopRenderer.prototype.removeAttribute = function removeAttribute(node, attrName) {
        };

        NoopRenderer.prototype.setProperty = function setProperty(node, propName, propValue) {
        };

        NoopRenderer.prototype.addClass = function addClass(node, className) {
        };

        NoopRenderer.prototype.removeClass = function addClass(node, className) {
        };

        NoopRenderer.prototype.setStyle = function setStyle(node, styleName, styleValue) {
        };

        NoopRenderer.prototype.addEventListener = function addEventListener(node, eventName, listenerFn) {
        };

        function MockNode(id, type, value) {
            this.id = id;
            this.type = type;
            this.value = value;
        }

        MockNode.prototype.toString = function() {
          return `${this.type} ${this.id}`;
        };

        MockNode.prototype.toFullString = function() {
            if (this.type === '#text') {
                return `${this.type} ${this.id} ${this.value}`;
            } else {
                return `${this.type} ${this.id}`;
            }
        };

        function LoggingRenderer() {
          this.uid = 0;
          this.instructions = [];
          this.root = new MockNode(this.uid++, '#root');
        }

        LoggingRenderer.prototype.clearInstructions = function clear() {
            this.instructions = [];
        };

        LoggingRenderer.prototype.createElement = function createElement(tagName) {
            var node = new MockNode(this.uid++, tagName);
            this.instructions.push(`CREATE ${node.toFullString()}`);

            return node;
        };

        LoggingRenderer.prototype.createText = function createText(value) {
            var node = new MockNode(this.uid++, '#text', value);
            this.instructions.push(`CREATE ${node.toFullString()}`);

            return node;
        };

        LoggingRenderer.prototype.updateText = function updateText(node, value) {
            node.value = value;
            this.instructions.push(`UPDATE ${node.toFullString()}`);
        };

        LoggingRenderer.prototype.appendChild = function appendChild(parentNode, childNode) {
            this.instructions.push(`APPEND ${parentNode} -> ${childNode}`);
        };

        LoggingRenderer.prototype.insertBefore = function insertBefore(parentNode, refNode, newNode) {
            this.instructions.push(`INSERT ${parentNode} -> ${newNode} before ${refNode}`);
        };

        LoggingRenderer.prototype.getRoot = function getRoot() {
            return this.root;
        };

        LoggingRenderer.prototype.removeNode = function removeNode(parentNode, node) {
            this.instructions.push(`DELETE ${parentNode} -> ${node}`);
        };

        LoggingRenderer.prototype.setProperty = function setProperty(node, propName, propValue) {
            node[propName] = propValue;
            this.instructions.push(`SET ${node} ${propName}=${propValue}`);
        };

        LoggingRenderer.prototype.setAttribute = function setAttribute(node, attrName, attrValue) {
            this.instructions.push(`SET_ATTR ${node} ${attrName}=${attrValue}`);
        };

        LoggingRenderer.prototype.removeAttribute = function removeAttribute(node, attrName) {
            this.instructions.push(`REMOVE_ATTR ${node} ${attrName}`);
        };

        LoggingRenderer.prototype.addClass = function addClass(node, className) {
            this.instructions.push(`ADD_CLASS ${node} ${className}`);
        };

        LoggingRenderer.prototype.removeClass = function addClass(node, className) {
            this.instructions.push(`REMOVE_CLASS ${node} ${className}`);
        };

        LoggingRenderer.prototype.setStyle = function setStyle(node, styleName, styleValue) {
            this.instructions.push(`SET_STYLE ${node} ${styleName}=${styleValue}`);
        };

        LoggingRenderer.prototype.addEventListener = function addEventListener(node, eventName, listenerFn) {
        };


        describe('VDOM interactions', function() {


            function getVDOM(cursor) {
                return cursor.vdom[0].children;
            }

            describe('single text node', function () {
                function app(cursor, data) {
                    if (data !== null) {
                        cursor = text(cursor, 0, data);
                    }

                    return cursor;
                }

                it('should create a single text node', function () {
                    var vdom = getVDOM(patch(new VDomCursor(noopRenderer), app, 'foo'));

                    expect(vdom.length).toBe(1);
                    expect(vdom[0].type).toBe('#text');
                    expect(vdom[0].value).toBe('foo');
                });

                it('should update a single text node', function () {
                    var cursor = patch(new VDomCursor(noopRenderer), app, 'foo');
                    var vdom = getVDOM(patch(cursor, app, 'bar'));

                    expect(vdom.length).toBe(1);
                    expect(vdom[0].type).toBe('#text');
                    expect(vdom[0].value).toBe('bar');
                });

                it('should delete a single text node', function () {
                    var cursor = patch(new VDomCursor(noopRenderer), app, 'foo');
                    var vdom = getVDOM(patch(cursor, app, null));

                    expect(vdom.length).toBe(0);
                });
            });

            describe('multiple text nodes', function () {

                function app(cursor, data) {
                    if (data !== null) {
                        if (data !== 'deleteFirst') {
                            cursor = text(cursor, 0, 'foo');
                        }
                        if (data !== 'deleteLast') {
                            cursor = text(cursor, 1, data);
                        }
                    }

                    return cursor;
                }

                it('should create several text nodes', function () {
                    var vdom = getVDOM(patch(new VDomCursor(noopRenderer), app, 'foo'));
                    expect(vdom.length).toBe(2);
                });

                it('should update selected text nodes', function () {
                    var cursor = patch(new VDomCursor(noopRenderer), app, 'foo');
                    var vdom = getVDOM(patch(cursor, app, 'bar'));
                    expect(vdom.length).toBe(2);
                    expect(vdom[0].value).toBe('foo');
                    expect(vdom[1].value).toBe('bar');
                });

                it('should delete all text nodes', function () {
                    var cursor = patch(new VDomCursor(noopRenderer), app, 'foo');
                    var vdom = getVDOM(patch(cursor, app, null));
                    expect(vdom.length).toBe(0);
                });

                it('should delete first text node', function () {
                    var cursor = patch(new VDomCursor(noopRenderer), app, 'bar');

                    var vdom = getVDOM(cursor);
                    expect(vdom.length).toBe(2);
                    expect(vdom[0].value).toBe('foo');
                    expect(vdom[1].value).toBe('bar');

                    vdom = getVDOM(patch(cursor, app, 'deleteFirst'));
                    expect(vdom.length).toBe(1);
                    expect(vdom[0].value).toBe('deleteFirst');
                });

                it('should delete last text node', function () {
                    var cursor = patch(new VDomCursor(noopRenderer), app, 'bar');
                    var vdom = getVDOM(patch(cursor, app, 'deleteLast'));
                    expect(vdom.length).toBe(1);
                    expect(vdom[0].value).toBe('foo');
                });
            });

            describe('elements', function () {

                it('should create single element', function () {
                    function app(cursor) {
                        return element(cursor, 0, 'span');
                    }

                    var vdom = getVDOM(patch(new VDomCursor(noopRenderer), app));
                    expect(vdom.length).toBe(1);
                    expect(vdom[0].type).toBe('span');
                });

                it('should create multiple elements in a loop', function () {
                    function app(cursor) {
                        for (var i=0; i<5; i++) {
                            cursor = element(cursor, 0, 'span');
                        }

                        return cursor;
                    }

                    var vdom = getVDOM(patch(new VDomCursor(noopRenderer), app));
                    expect(vdom.length).toBe(5);
                    expect(vdom[0].type).toBe('span');
                });

                it('should create elements with sibling container elements', function() {
                    function app(c) {
                        c = elementStart(c, 0, 'div');
                            c = elementStart(c, 0, 'h4');
                                c = text(c, 0, 'foo');
                            c = elementEnd(c);
                            c = elementStart(c, 0, 'h4');
                                c = text(c, 0, 'bar');
                            c = elementEnd(c);
                        c = elementEnd(c);

                        return c;
                    }

                    var vdom = getVDOM(patch(new VDomCursor(noopRenderer), app));
                    expect(vdom.length).toBe(1);
                    expect(vdom[0].type).toBe('div');

                    var divChildren = vdom[0].children;
                    expect(divChildren.length).toBe(2);
                    expect(divChildren[0].type).toBe('h4');
                    expect(divChildren[1].type).toBe('h4');
                });

                it('should create and update multiple elements from a function', function () {
                    function subComponent(cursor) {
                        cursor = element(cursor, 0, 'span', null, null);
                        cursor = element(cursor, 1, 'span', null, null);

                        return cursor;
                    }

                    function app(cursor, callSubComponent) {
                        cursor = element(cursor, 0, 'div');
                        if (callSubComponent) {
                            cursor = view(cursor, 1, subComponent);
                        }
                        cursor = element(cursor, 2, 'div');

                        return cursor;
                    }

                    var cursor = patch(new VDomCursor(noopRenderer), app, true);
                    var vdom = getVDOM(cursor);
                    expect(vdom.length).toBe(3);
                    expect(vdom[0].type).toBe('div');
                    expect(vdom[1].type).toBe('#view');
                    expect(vdom[1].children[0].type).toBe('span');
                    expect(vdom[1].children[1].type).toBe('span');
                    expect(vdom[2].type).toBe('div');

                    vdom = getVDOM(patch(cursor, app, false));
                    expect(vdom.length).toBe(2);
                    expect(vdom[0].type).toBe('div');
                    expect(vdom[1].type).toBe('div');
                });

                it('should delete single elements at the begining', function () {
                    function app(cursor, deleteFirst) {
                        if (!deleteFirst) {
                            cursor = element(cursor, 0, 'span');
                        }
                        return element(cursor, 1, 'div');
                    }

                    var cursor = patch(new VDomCursor(noopRenderer), app, false);
                    var vdom = getVDOM(cursor);
                    expect(vdom.length).toBe(2);
                    expect(vdom[0].type).toBe('span');
                    expect(vdom[1].type).toBe('div');

                    vdom = getVDOM(patch(cursor, app, true));
                    expect(vdom.length).toBe(1);
                    expect(vdom[0].type).toBe('div');
                });

                it('should create mix of elements and text nodes', function () {
                    function appMix(cursor) {
                        cursor = element(cursor, 0, 'span');
                        cursor = text(cursor, 1, 'foo');
                        return element(cursor, 2, 'div');
                    }

                    var vdom = getVDOM(patch(new VDomCursor(noopRenderer), appMix, 'foo'));
                    expect(vdom.length).toBe(3);
                    expect(vdom[0].type).toBe('span');
                    expect(vdom[1].value).toBe('foo');
                    expect(vdom[2].type).toBe('div');
                });

                it('should replace elements if needed', function() {
                   function swappingElementsApp(cursor, data) {
                       if (data) {
                           cursor = element(cursor, 0, 'span');
                       } else {
                           cursor = element(cursor, 1, 'div');
                       }
                       return cursor;
                   }

                    var cursor = patch(new VDomCursor(noopRenderer), swappingElementsApp, true);
                    var vdom = getVDOM(cursor);
                    expect(vdom.length).toBe(1);
                    expect(vdom[0].type).toBe('span');

                    vdom = getVDOM(patch(cursor, swappingElementsApp, false));
                    expect(vdom.length).toBe(1);
                    expect(vdom[0].type).toBe('div');
                });

                it('should replace elements by text nodes if needed', function() {
                    function swappingElementsApp(cursor, data) {
                        if (data) {
                            cursor = element(cursor, 0, 'span');
                        } else {
                            cursor = text(cursor, 1, 'ha!');
                        }
                        return cursor;
                    }

                    var cursor = patch(new VDomCursor(noopRenderer), swappingElementsApp, true);
                    var vdom = getVDOM(cursor);
                    expect(vdom.length).toBe(1);
                    expect(vdom[0].type).toBe('span');

                    vdom = getVDOM(patch(cursor, swappingElementsApp, false));
                    expect(vdom.length).toBe(1);
                    expect(vdom[0].type).toBe('#text');
                    expect(vdom[0].value).toBe('ha!');
                });
            });

            describe('elements with properties', function() {

                it('should support creation of elements with dynamic properties', function() {
                    function dynamicPropsApp(cursor, data) {
                        return element(cursor, 0, 'div', null, {props: data});
                    }

                    var cursor = patch(new VDomCursor(noopRenderer), dynamicPropsApp, {id: 'some_id'});
                    var vdom = getVDOM(cursor);
                    expect(vdom.length).toBe(1);
                    expect(vdom[0].type).toBe('div');
                    expect(vdom[0].bindings.props.id).toBe('some_id');

                    vdom = getVDOM(patch(cursor, dynamicPropsApp, {id: 'some_other_id'}));
                    expect(vdom.length).toBe(1);
                    expect(vdom[0].type).toBe('div');
                    expect(vdom[0].bindings.props.id).toBe('some_other_id');
                });
            });

            describe('elements with class bindings', function() {

                it('should support creation of elements with dynamic class bindings', function() {
                    function dynamicPropsApp(cursor, condition) {
                        return element(cursor, 0, 'div', null, {classes: {foo: condition}});
                    }

                    var cursor = patch(new VDomCursor(noopRenderer), dynamicPropsApp, true);
                    var vdom = getVDOM(cursor);
                    expect(vdom.length).toBe(1);
                    expect(vdom[0].type).toBe('div');
                    expect(vdom[0].bindings.classes.foo).toBeTruthy();

                    vdom = getVDOM(patch(cursor, dynamicPropsApp, false));
                    expect(vdom[0].bindings.classes.foo).toBeFalsy();
                });
            });

            describe('elements with children', function() {

                it('should support creation of elements with children', function() {
                    function childrenApp(cursor) {
                        cursor = elementStart(cursor, 0, 'div');
                        cursor = element(cursor, 0, 'span');
                        cursor = element(cursor, 1, 'div');
                        cursor = childrenEnd(cursor);

                        return cursor;
                    }

                    var vdom = getVDOM(patch(new VDomCursor(noopRenderer), childrenApp, null));

                    expect(vdom.length).toBe(1);
                    expect(vdom[0].type).toBe('div');
                    expect(vdom[0].children.length).toBe(2);
                    expect(vdom[0].children[0].type).toBe('span');
                    expect(vdom[0].children[1].type).toBe('div');
                });


                it('should support update of children elements', function() {
                    function childrenApp(cursor, keepLastChild) {
                        cursor = elementStart(cursor, 0, 'div');
                        cursor = element(cursor, 0, 'span');
                        if (keepLastChild) {
                            cursor = element(cursor, 1, 'div');
                        }
                        cursor = childrenEnd(cursor);

                        return cursor;
                    }

                    var cursor = patch(new VDomCursor(noopRenderer), childrenApp, true);
                    var vdom = getVDOM(cursor);
                    
                    expect(vdom.length).toBe(1);
                    expect(vdom[0].type).toBe('div');
                    expect(vdom[0].children.length).toBe(2);
                    expect(vdom[0].children[0].type).toBe('span');
                    expect(vdom[0].children[1].type).toBe('div');

                    cursor = getVDOM(patch(cursor, childrenApp, false));
                    expect(vdom.length).toBe(1);
                    expect(vdom[0].type).toBe('div');
                    expect(vdom[0].children.length).toBe(1);
                    expect(vdom[0].children[0].type).toBe('span');
                });
            });

            describe('views', function() {

                it('should allow views attached to root', function() {
                    function textView(cursor) {
                        return text(cursor, 0, 'from view');
                    }

                    function app(cursor) {
                        return view(cursor, 0, textView);
                    }

                    var vdom = getVDOM(patch(new VDomCursor(noopRenderer), app));
                    expect(vdom.length).toBe(1);
                    expect(vdom[0].type).toBe('#view');
                    expect(vdom[0].children.length).toBe(1);
                    expect(vdom[0].children[0].type).toBe('#text');
                });

                it('should allow swapping viewFn', function() {
                    function textFooView(cursor) {
                        return text(cursor, 0, 'foo');
                    }

                    function textSpanView(cursor) {
                        return element(cursor, 0, 'span');
                    }

                    function app(cursor, useFoo) {
                        return view(cursor, 0, useFoo ? textFooView : textSpanView);
                    }

                    var cursor = patch(new VDomCursor(noopRenderer), app, true);
                    var vdom = getVDOM(cursor);
                    expect(vdom[0].children[0].type).toBe('#text');
                    expect(vdom[0].children[0].value).toBe('foo');

                    cursor = patch(cursor, app, false);
                    vdom = getVDOM(cursor);
                    expect(vdom[0].children[0].type).toBe('span');
                });

            });

            describe('components', function() {

                it('should instantiate a component and use its render method', function() {
                    function TestCmpt() {
                    }

                    TestCmpt.prototype.render = function render(cursor) {
                        return text(cursor, 0, 'from component');
                    };


                    function app(cursor) {
                        return component(cursor, 0, TestCmpt);
                    }

                    var cursor = patch(new VDomCursor(noopRenderer), app);
                    var vdom = getVDOM(cursor);

                    expect(vdom.length).toBe(1);
                    expect(vdom[0].type).toBe('#view');
                    expect(vdom[0].children.length).toBe(1);
                    expect(vdom[0].children[0].type).toBe('#text');
                    expect(vdom[0].children[0].value).toBe('from component');
                });

                it('should keep a component instance around between refresh cycles', function() {
                    function TestCmpt() {
                        this.counter = 0;
                    }

                    TestCmpt.prototype.render = function render(cursor) {
                        return text(cursor, 0, '' + this.counter++);
                    };


                    function app(cursor) {
                        return component(cursor, 0, TestCmpt);
                    }

                    var cursor = patch(new VDomCursor(noopRenderer), app);
                    var vdom = getVDOM(cursor);

                    expect(vdom.length).toBe(1);
                    expect(vdom[0].type).toBe('#view');
                    expect(vdom[0].children.length).toBe(1);
                    expect(vdom[0].children[0].type).toBe('#text');
                    expect(vdom[0].children[0].value).toBe('0');

                    cursor = patch(cursor, app);
                    vdom = getVDOM(cursor);
                    expect(vdom[0].children[0].value).toBe('1');

                    cursor = patch(cursor, app);
                    vdom = getVDOM(cursor);
                    expect(vdom[0].children[0].value).toBe('2');
                });

                it('should propagate inputs to a components render function', function() {
                    function TestCmpt() {
                    }

                    TestCmpt.prototype.render = function render(cursor, inputs) {
                        return text(cursor, 0, inputs.text);
                    };


                    function app(cursor, data) {
                        return component(cursor, 0, TestCmpt, data);
                    }

                    var cursor = patch(new VDomCursor(noopRenderer), app, {text: 'foo'});
                    var vdom = getVDOM(cursor);
                    expect(vdom[0].children[0].value).toBe('foo');

                    cursor = patch(cursor, app, {text: 'bar'});
                    vdom = getVDOM(cursor);
                    expect(vdom[0].children[0].value).toBe('bar');
                });

                it('should allow swapping component instance', function() {
                    function CounterCmpt() {
                    }
                    CounterCmpt.prototype.render = function render(cursor) {
                        return text(cursor, 0, '0');
                    };

                    function BigCounterCmpt() {
                    }
                    BigCounterCmpt.prototype.render = function render(cursor) {
                        return text(cursor, 1, '100');
                    };


                    function app(cursor, isBig) {
                        return component(cursor, 0, isBig ? BigCounterCmpt : CounterCmpt);
                    }

                    var cursor = patch(new VDomCursor(noopRenderer), app, false);
                    var vdom = getVDOM(cursor);
                    expect(vdom.length).toBe(1);
                    expect(vdom[0].type).toBe('#view');
                    expect(vdom[0].children.length).toBe(1);
                    expect(vdom[0].children[0].type).toBe('#text');
                    expect(vdom[0].children[0].value).toBe('0');

                    cursor = patch(cursor, app, true);
                    vdom = getVDOM(cursor);
                    expect(vdom[0].children[0].value).toBe('100');
                });

                it('should support OnPush-like guard fn for components', function() {
                    function CounterCmpt() {
                        this.counter = 0;
                    }

                    CounterCmpt.prototype.render = function render(c) {
                       return text(c, 0, '' + this.counter++);
                    };

                    CounterCmpt.prototype.shouldUpdate = function shouldUpdate(inputs) {
                        return inputs;
                    };

                    function app(c, shouldUpdate) {
                        return component(c, 0, CounterCmpt, shouldUpdate);
                    }

                    //initial rendering - should ignore update flag
                    var cursor = patch(new VDomCursor(noopRenderer), app, false);
                    var vdom = getVDOM(cursor);
                    expect(vdom[0].children[0].value).toBe('0');

                    //update mode with view rendering
                    cursor = patch(cursor, app, true);
                    vdom = getVDOM(cursor);
                    expect(vdom[0].children[0].value).toBe('1');

                    //update mode with view rendering ignore
                    cursor = patch(cursor, app, false);
                    vdom = getVDOM(cursor);
                    expect(vdom[0].children[0].value).toBe('1');

                    //update mode with view rendering on again
                    cursor = patch(cursor, app, true);
                    vdom = getVDOM(cursor);
                    expect(vdom[0].children[0].value).toBe('2');
                });
            });
        });

        describe('Renderer interactions', function() {
            var loggingRenderer;

            function app(cursor, data) {
                return text(cursor, 0, data);
            }

            beforeEach(function() {
                loggingRenderer = new LoggingRenderer();
            });

            describe('text nodes', function() {

                it('should create text node', function() {
                    patch(new VDomCursor(loggingRenderer), app, 'foo');
                    expect(loggingRenderer.instructions.length).toBe(2);
                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'CREATE #text 1 foo',
                        'APPEND #root 0 -> #text 1'
                    ].join('\n'));
                });

                it('should create and update text node', function() {
                    var cursor = patch(new VDomCursor(loggingRenderer), app, 'foo');
                    cursor = patch(cursor, app, 'bar');

                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'CREATE #text 1 foo',
                        'APPEND #root 0 -> #text 1',
                        'UPDATE #text 1 bar'
                    ].join('\n'));
                });

                it('should do nothing when value doesnt change', function() {
                    var cursor = patch(new VDomCursor(loggingRenderer), app, 'foo');
                    cursor = patch(cursor, app, 'foo');

                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'CREATE #text 1 foo',
                        'APPEND #root 0 -> #text 1'
                    ].join('\n'));
                });

                it('should remove text nodes from the start', function() {
                    function deleteApp(cursor, keep) {
                        if (keep) {
                            return text(cursor, 0, 'here!');
                        }
                        return cursor;
                    }

                    var cursor = patch(new VDomCursor(loggingRenderer), deleteApp, true);
                    cursor = patch(cursor, deleteApp, false);

                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'CREATE #text 1 here!',
                        'APPEND #root 0 -> #text 1',
                        'DELETE #root 0 -> #text 1'
                    ].join('\n'));
                });

                it('should remove text nodes in the middle', function() {
                    function deleteApp(cursor, keep) {
                        cursor = text(cursor, 0, 'before');
                        if (keep) {
                            cursor = text(cursor, 1, 'here!');
                        }
                        cursor = text(cursor, 2, 'after');
                        return cursor;
                    }

                    var cursor = patch(new VDomCursor(loggingRenderer), deleteApp, true);
                    cursor = patch(cursor, deleteApp, false);

                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'CREATE #text 1 before',
                        'APPEND #root 0 -> #text 1',
                        'CREATE #text 2 here!',
                        'APPEND #root 0 -> #text 2',
                        'CREATE #text 3 after',
                        'APPEND #root 0 -> #text 3',
                        'DELETE #root 0 -> #text 2'
                    ].join('\n'));
                });

                it('should remove text nodes from the end', function() {
                    function deleteApp(cursor, keep) {
                        cursor = text(cursor, 0, 'before');
                        if (keep) {
                            cursor = text(cursor, 1, 'here!');
                        }
                        return cursor;
                    }

                    var cursor = patch(new VDomCursor(loggingRenderer), deleteApp, true);
                    cursor = patch(cursor, deleteApp, false);

                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'CREATE #text 1 before',
                        'APPEND #root 0 -> #text 1',
                        'CREATE #text 2 here!',
                        'APPEND #root 0 -> #text 2',
                        'DELETE #root 0 -> #text 2'
                    ].join('\n'));
                });


            });

            describe('void elements without properties', function() {
                function app(cursor, data) {
                    return element(cursor, 0, 'br');
                }

                it('should create void elements and attach them to the root', function() {
                    patch(new VDomCursor(loggingRenderer), app, 'foo');

                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'CREATE br 1',
                        'APPEND #root 0 -> br 1'
                    ].join('\n'));
                });

                it('should do nothing when there is no update to the void node', function() {
                    var cursor = patch(new VDomCursor(loggingRenderer), app, 'foo');
                    cursor = patch(cursor, app, 'foo');

                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'CREATE br 1',
                        'APPEND #root 0 -> br 1'
                    ].join('\n'));
                });
            });

            describe('void elements with properties', function() {
                function imgApp(cursor) {
                    return element(cursor, 0, 'img', {src: 'image.png'});
                }

                it('should create elements, set attributes and attach to the root', function() {
                    patch(new VDomCursor(loggingRenderer), imgApp, 'foo');

                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'CREATE img 1',
                        'SET_ATTR img 1 src=image.png',
                        'APPEND #root 0 -> img 1'
                    ].join('\n'));
                });

                it('should do noting on update when only attributes are present', function() {
                    var cursor = patch(new VDomCursor(loggingRenderer), imgApp);
                    cursor = patch(cursor, imgApp);
                    cursor = patch(cursor, imgApp);

                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'CREATE img 1',
                        'SET_ATTR img 1 src=image.png',
                        'APPEND #root 0 -> img 1'
                    ].join('\n'));
                });

                it('should only update dynamic properties that change', function() {
                    function imgSizeApp(cursor, isBig) {
                        return element(cursor, 0, 'img', {src: 'image.png'}, {props: {width: isBig ? 100 : 10, height: 10}});
                    }

                    var cursor = patch(new VDomCursor(loggingRenderer), imgSizeApp, false);
                    cursor = patch(cursor, imgSizeApp, true);

                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'CREATE img 1',
                        'SET_ATTR img 1 src=image.png',
                        'SET img 1 width=10',
                        'SET img 1 height=10',
                        'APPEND #root 0 -> img 1',
                        'SET img 1 width=100'
                    ].join('\n'));
                });

            });

            describe('elements with CSS class bindings', function() {

                function withCSSApp(cursor, condition) {
                    return element(cursor, 0, 'div', {'class': 'foo'}, {classes: {
                        'bar': condition
                    }});
                }

                it('should create elements with CSS classes and support bindings to classes', function() {
                    var cursor = patch(new VDomCursor(loggingRenderer), withCSSApp, false);

                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'CREATE div 1',
                        'SET_ATTR div 1 class=foo',
                        'APPEND #root 0 -> div 1'
                    ].join('\n'));

                    loggingRenderer.clearInstructions();
                    cursor = patch(cursor, withCSSApp, true);
                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'ADD_CLASS div 1 bar'
                    ].join('\n'));

                    loggingRenderer.clearInstructions();
                    cursor = patch(cursor, withCSSApp, false);
                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'REMOVE_CLASS div 1 bar'
                    ].join('\n'));
                });
            });

            describe('elements with attribute bindings', function() {

                function withAttrs(cursor, value) {
                    return element(cursor, 0, 'div', null, {attrs: {
                        id: value
                    }});
                }

                it('should create elements and support bindings to attributes', function() {
                    var cursor = patch(new VDomCursor(loggingRenderer), withAttrs, 'foo');

                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'CREATE div 1',
                        'SET_ATTR div 1 id=foo',
                        'APPEND #root 0 -> div 1'
                    ].join('\n'));

                    loggingRenderer.clearInstructions();
                    cursor = patch(cursor, withAttrs, 'bar');
                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'SET_ATTR div 1 id=bar'
                    ].join('\n'));

                    loggingRenderer.clearInstructions();
                    cursor = patch(cursor, withAttrs, null);
                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'REMOVE_ATTR div 1 id'
                    ].join('\n'));
                });
            });

            describe('elements with styles bindings', function() {

                function withStyles(cursor, color) {
                    return element(cursor, 0, 'div', null, {styles: {
                        'background-color': color
                    }});
                }

                it('should create elements and support bindings to attributes', function() {
                    var cursor = patch(new VDomCursor(loggingRenderer), withStyles, 'red');

                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'CREATE div 1',
                        'SET_STYLE div 1 background-color=red',
                        'APPEND #root 0 -> div 1'
                    ].join('\n'));

                    loggingRenderer.clearInstructions();
                    cursor = patch(cursor, withStyles, 'green');
                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'SET_STYLE div 1 background-color=green',
                    ].join('\n'));
                });
            });

            describe('parent -> child elements', function() {

               it('should create and remove children for a given parent', function() {
                   function removeChildApp(c, keepChild) {
                       c = elementStart(c, 0, 'div');
                       if (keepChild) {
                           c = element(c, 0, 'span');
                       }
                       c = elementEnd(c);

                       return c;
                   }

                   var cursor = patch(new VDomCursor(loggingRenderer), removeChildApp, true);
                   expect(loggingRenderer.instructions.join('\n')).toEqual([
                       'CREATE div 1',
                       'APPEND #root 0 -> div 1',
                       'CREATE span 2',
                       'APPEND div 1 -> span 2',
                   ].join('\n'));

                   loggingRenderer.clearInstructions();
                   cursor = patch(cursor, removeChildApp, false);
                   expect(loggingRenderer.instructions.join('\n')).toEqual([
                       'DELETE div 1 -> span 2',
                   ].join('\n'));
               })
            });

            describe('views', function() {
               function simpleView(c) {
                   return text(c, 0, 'foo');
               }

               it('should append view nodes to root in the creation mode', function() {
                   function app(c) {
                       return view(c, 0, simpleView);
                   }

                   patch(new VDomCursor(loggingRenderer), app, true);

                   expect(loggingRenderer.instructions.join('\n')).toEqual([
                       'CREATE #text 1 foo',
                       'APPEND #root 0 -> #text 1',
                   ].join('\n'));
               });

                it('should append view nodes to container element in the creation mode', function() {
                    function app(c) {
                        c = elementStart(c, 0, 'div');
                        c = view(c, 0, simpleView);
                        c = elementEnd(c);

                        return c;
                    }

                    patch(new VDomCursor(loggingRenderer), app, true);

                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'CREATE div 1',
                        'APPEND #root 0 -> div 1',
                        'CREATE #text 2 foo',
                        'APPEND div 1 -> #text 2'
                    ].join('\n'));
                });


                it('should append view nodes to container element in the update mode and view elements are at the end of view', function() {
                    function twoElsView(c, addLast) {
                        c = text(c, 0, 'before');
                        if (addLast) {
                            c = text(c, 1, 'after');
                        }

                        return c;
                    }

                    function app(c, addLast) {
                        return view(c, 0, twoElsView, addLast);
                    }

                    var c = patch(new VDomCursor(loggingRenderer), app, false);
                    loggingRenderer.clearInstructions();

                    patch(c, app, true);

                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'CREATE #text 2 after',
                        'APPEND #root 0 -> #text 2'
                    ].join('\n'));
                });

                it('should insert view nodes to container element in the update mode and view elements are not at the end of view', function() {
                    function twoElsView(c, addFirst) {
                        if (addFirst) {
                           c = text(c, 0, 'before');
                        }
                        c = text(c, 1, 'after');

                        return c;
                    }

                    function app(c, addFirst) {
                        return view(c, 0, twoElsView, addFirst);
                    }

                    var c = patch(new VDomCursor(loggingRenderer), app, false);
                    loggingRenderer.clearInstructions();

                    patch(c, app, true);

                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'CREATE #text 2 before',
                        'INSERT #root 0 -> #text 2 before #text 1'
                    ].join('\n'));
                });

                it('should remove and add nodes when re-creating view on viewFn change', function() {
                    function complexView(c) {
                        return text(c, 0, 'complex');
                    }

                    function app(c, isSimple) {
                        return view(c, 0, isSimple ? simpleView : complexView);
                    }

                    var c = new VDomCursor(loggingRenderer);

                    patch(c, app, true);
                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'CREATE #text 1 foo',
                        'APPEND #root 0 -> #text 1',
                    ].join('\n'));

                    loggingRenderer.clearInstructions();
                    patch(c, app, false);
                    expect(loggingRenderer.instructions.join('\n')).toEqual([
                        'DELETE #root 0 -> #text 1',
                        'CREATE #text 2 complex',
                        'APPEND #root 0 -> #text 2',
                    ].join('\n'));
                });

            });
        });
    </script>
</head>
<body>

</body>
</html>